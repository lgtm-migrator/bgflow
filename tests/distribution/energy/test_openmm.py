
import pytest
import simtk.openmm
import torch
import warnings
import numpy as np

from bgflow.distribution.energy.openmm import OpenMMBridge, OpenMMEnergy


# OpenMM conditional import
with warnings.catch_warnings():
    warnings.simplefilter(
        "ignore", DeprecationWarning
    )  # ignore warnings inside OpenMM
    try:
            import openmm
            from openmm import unit
    except ImportError:
            openmm = pytest.importorskip("simtk.openmm", reason="Tests require openmm.")
            unit = pytest.importorskip("simtk.unit", reason="Tests require openmm.")


class OneParticleTestBridge(OpenMMBridge):
    """OpenMM bridge for a system with one particle"""

    def __init__(self, n_workers=1, n_simulation_steps=0):
        # a system with one particle and an external dummy force
        system = openmm.System()
        system.addParticle(1.0 * unit.amu)
        force = openmm.CustomExternalForce("x")
        force.addParticle(0)
        system.addForce(force)

        super(OneParticleTestBridge, self).__init__(
            system,
            openmm.LangevinIntegrator(
                300 * unit.kelvin, 1.0 / unit.picoseconds, 1.0 * unit.femtoseconds
            ),
            n_workers=n_workers,
            n_simulation_steps=n_simulation_steps,
        )


class PeriodicTwoParticleTestBridge(OpenMMBridge):
    """OpenMM bridge for a system with one particle"""

    def __init__(self, n_workers=1, n_simulation_steps=0):
        # a system with one particle and an external dummy force
        system = openmm.System()
        system.addParticle(1.0 * unit.amu)
        system.addParticle(2.0 * unit.amu)
        force = openmm.HarmonicBondForce()
        force.setUsesPeriodicBoundaryConditions(True)
        force.addBond(0, 1, 10.0, 20.0)
        system.addForce(force)

        system.setDefaultPeriodicBoxVectors(*np.eye(3))
        system.addForce(openmm.MonteCarloBarostat(10., 300., 1))

        super().__init__(
            system,
            openmm.LangevinIntegrator(
                300 * unit.kelvin, 1.0 / unit.picoseconds, 1.0 * unit.femtoseconds
            ),
            n_workers=n_workers,
            n_simulation_steps=n_simulation_steps,
            err_handling="exception"
        )


@pytest.mark.parametrize("n_workers", [1, 2, 8])
@pytest.mark.parametrize("n_simulation_steps", [0, 100])
def test_openmm_bridge_evaluate_dummy(n_workers, n_simulation_steps):
    """Test if we can evaluate an energy; skip test if openmm is not installed."""

    bridge = OneParticleTestBridge(n_workers, n_simulation_steps)

    # test forces and energies generated by the bridge
    batch_size = 4
    positions = torch.tensor([[0.1, 0.0, 0.0]] * batch_size)
    kT = unit.MOLAR_GAS_CONSTANT_R * 300 * unit.kelvin
    energies, forces, *_ = bridge.evaluate(positions)
    assert energies.shape == torch.Size([batch_size, 1])
    assert forces.shape == torch.Size([batch_size, 3])
    if n_simulation_steps == 0:
        assert energies.numpy()[0] == pytest.approx(
            [0.1 * unit.kilojoule_per_mole / kT], abs=1e-8, rel=0
        )
        assert forces.numpy()[0] == pytest.approx(
            [-1.0 * unit.kilojoule_per_mole / kT, 0.0, 0.0], abs=1e-8, rel=0
        )
    else:
        assert energies.numpy()[0] != pytest.approx(
            [0.1 * unit.kilojoule_per_mole / kT], abs=1e-8, rel=0
        )


# run 'pytest --durations 0' to print the time it takes to evaluate
# change batch_size and n_workers to profile
@pytest.mark.parametrize("testsystem_name", ["AlanineDipeptideImplicit", "WaterBox"])
@pytest.mark.parametrize("batch_size", [1, 8])
@pytest.mark.parametrize("n_workers", [1, 8])
def test_openmm_bridge_evaluate_openmmtools_testsystem(
    testsystem_name, batch_size, n_workers
):
    """Test if we can evaluate an energy; skip test if openmm is not installed."""
    warnings.filterwarnings(
        "ignore", category=RuntimeWarning, message="numpy.ufunc size changed"
    )

    #if testsystem_name == "WaterBox" and n_workers == 1:
    #    pytest.skip()
    # prevent openmm hanging (this is possibly a bug in their PME code)
    # see https://github.com/openmm/openmm/issues/2602

    testsystems = pytest.importorskip("openmmtools.testsystems", reason="Test requires openmmtools.")
    Testsystem = getattr(testsystems, testsystem_name)

    # alanine dipeptide or water testsystem
    testsystem = Testsystem()
    system = testsystem.system

    # test forces and energies generated by the bridge
    bridge = OpenMMBridge(
        system,
        openmm.LangevinIntegrator(
            300 * unit.kelvin, 1.0 / unit.picoseconds, 1.0 * unit.femtoseconds
        ),
        n_workers=n_workers,
    )
    batch = torch.tensor(
        np.array(
            [np.ravel(testsystem.positions.value_in_unit(unit.nanometer))] * batch_size
        )
    )
    energies, forces, *_ = bridge.evaluate(batch)
    assert energies.shape == torch.Size([batch_size, 1])
    assert forces.shape == torch.Size([batch_size, 3 * len(testsystem.positions)])


@pytest.mark.parametrize("n_workers", [1, 8])
def test_openmm_bridge_velocities(n_workers):
    bridge = OneParticleTestBridge(n_workers=n_workers, n_simulation_steps=100)

    batch_size = 4
    positions = torch.tensor([[0.1, 0.0, 0.0]] * batch_size)
    velocities = torch.zeros_like(positions)
    openmm_output = bridge.evaluate(
        positions, velocity_batch=velocities, evaluate_velocities=True, evaluate_positions=True
    )
    assert openmm_output.new_velocities.shape == openmm_output.new_positions.shape
    # test that propagation has happened
    assert not torch.allclose(openmm_output.new_velocities, velocities)
    assert not torch.allclose(openmm_output.new_positions, positions)


@pytest.mark.parametrize("n_workers", [1, 8])
def test_openmm_bridge_temperature_scaling(n_workers):
    bridge = OneParticleTestBridge(n_workers=n_workers, n_simulation_steps=0)

    batch_size = 2
    positions = torch.tensor([[0.1, 0.0, 0.0]] * batch_size)
    openmm_output = bridge.evaluate(
        positions, temperature_scaling_batch=torch.tensor([1.0, 10.0])
    )
    assert torch.allclose(openmm_output.energies[0], 10*openmm_output.energies[1])


@pytest.mark.parametrize("n_workers", [1, 8])
@pytest.mark.parametrize("n_simulation_steps", [0, 2])
def test_openmm_bridge_box_vectors(n_workers, n_simulation_steps):
    bridge = PeriodicTwoParticleTestBridge(n_workers=n_workers, n_simulation_steps=n_simulation_steps)

    batch_size = 2
    positions = torch.tensor([[0.1, 0.0, 0.0] * 2] * batch_size)
    box_vectors = torch.arange(1, 1+batch_size)[:, None, None]*torch.eye(3).reshape(1, 3, 3)
    openmm_output = bridge.evaluate(
        positions,
        box_vector_batch=box_vectors,
        evaluate_box_vectors=True,
        evaluate_positions=True
    )
    assert torch.allclose(openmm_output.new_box_vectors, box_vectors) == (n_simulation_steps == 0)
    assert not torch.any(torch.isinf(openmm_output.energies))


def test_openmm_bridge_cache():
    """Test if hashing and caching works."""
    bridge = OneParticleTestBridge()
    omm_energy = OpenMMEnergy(3, bridge)
    omm_energy._energy(torch.tensor([[0.1, 0.0, 0.0]] * 2))
    hash1 = omm_energy._last_batch
    omm_energy._energy(torch.tensor([[0.2, 0.0, 0.0]] * 2))
    assert omm_energy._last_batch != hash1
    omm_energy._energy(torch.tensor([[0.1, 0.0, 0.0]] * 2))
    assert omm_energy._last_batch == hash1
    omm_energy._energy(torch.tensor([[0.1, 0.0, 0.0]] * 2))

    # test if forces are in the same memory location for same input batch
    force_address = hex(id(omm_energy._openmm_energy_bridge.last_output.forces))
    force = (
        omm_energy._openmm_energy_bridge.last_output.forces
    )  # retain a pointer to last forces so that memory is not freed
    assert (
        hex(id(omm_energy.force(torch.tensor([[0.1, 0.0, 0.0]] * 2)))) == force_address
    )
    assert (
        hex(id(omm_energy.force(torch.tensor([[0.1, 0.0, 0.0]] * 2)))) == force_address
    )
    assert (
        hex(id(omm_energy.force(torch.tensor([[0.2, 0.0, 0.0]] * 2)))) != force_address
    )
    assert (
        hex(id(omm_energy.force(torch.tensor([[0.1, 0.0, 0.0]] * 2)))) != force_address
    )

    # suppress flake8 F841 warning
    force


# Returned log path probability ratios / positions are tested in the SNF tests
